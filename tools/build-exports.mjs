/**
 *	@Project: @cldmv/slothlet
 *	@Filename: /tools/build-exports.mjs
 *	@Date: 2025-09-09 13:22:38 -07:00 (1757449358)
 *	@Author: Nate Hyson <CLDMV>
 *	@Email: <Shinrai@users.noreply.github.com>
 *	-----
 *	@Last modified by: Nate Hyson <CLDMV> (Shinrai@users.noreply.github.com)
 *	@Last modified time: 2025-10-22 07:01:29 -07:00 (1761141689)
 *	-----
 *	@Copyright: Copyright (c) 2013-2025 Catalyzed Motivation Inc. All rights reserved.
 */

/**
 * @fileoverview Build script to automatically generate export statements for index files by scanning src/slothlet.mjs for all exports.
 * @module @cldmv/slothlet/tools/build-exports
 * @package
 * @internal
 * @description
 * Automatically generates `index.mjs` and TypeScript declaration files by scanning the main
 * slothlet source file for exports. This ensures that entry points stay in sync with the
 * actual exports from the core module without manual maintenance.
 *
 * Key features:
 * - Parses both named and default exports from source files
 * - Generates ESM entry point with auto-detection (dist/ vs src/)
 * - Creates TypeScript declaration files with proper type re-exports
 * - Preserves query parameters for multi-instance coordination
 * - Handles destructured export statements
 *
 * Technical implementation:
 * - Uses regex parsing to extract export statements from JavaScript source
 * - Generates template-based index files with dynamic export lists
 * - Creates separate TypeScript declarations for proper IDE support
 * - Implements fallback logic for development vs production builds
 *
 * @example
 * // Run the build script
 * npm run build:exports
 *
 * @example
 * // Use programmatically
 * import { buildExports } from "./tools/build-exports.mjs";
 * await buildExports();
 */

import fs from "node:fs";
import path from "node:path";
import { fileURLToPath } from "node:url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const projectRoot = path.dirname(__dirname);

/**
 * Parse a JavaScript file and extract all export statements.
 * Analyzes both regular export declarations and destructured exports.
 * @internal
 * @private
 * @param {string} filePath - Path to the JavaScript file
 * @returns {{named: string[], hasDefault: boolean, defaultName: string|null}} Object containing named exports and default export info
 */
function parseExports(filePath) {
	const content = fs.readFileSync(filePath, "utf8");
	const exports = {
		named: new Set(),
		hasDefault: false,
		defaultName: null
	};

	// Match export statements
	const exportRegex = /^export\s+(?:(default)\s+)?(?:(const|let|var|function|class)\s+)?([^=\s{;]+)?/gm;
	const destructuredExportRegex = /^export\s+\{\s*([^}]+)\s*\}/gm;

	let match;

	// Find regular exports
	while ((match = exportRegex.exec(content)) !== null) {
		const [, isDefault, , name] = match;

		if (isDefault) {
			exports.hasDefault = true;
			if (name && name.trim()) {
				exports.defaultName = name.trim();
			}
		} else if (name && name.trim()) {
			const cleanName = name.trim().split(/[=\s(]/)[0]; // Handle function names, assignments, etc.
			if (cleanName) {
				exports.named.add(cleanName);
			}
		}
	}

	// Find destructured exports like export { name1, name2 }
	while ((match = destructuredExportRegex.exec(content)) !== null) {
		const exportList = match[1];
		const names = exportList.split(",").map((n) =>
			n
				.trim()
				.split(/\s+as\s+/)[0]
				.trim()
		);
		names.forEach((name) => {
			if (name) exports.named.add(name);
		});
	}

	return {
		named: Array.from(exports.named).sort(),
		hasDefault: exports.hasDefault,
		defaultName: exports.defaultName
	};
}

/**
 * Generate TypeScript declaration content.
 * Creates TypeScript definitions that re-export from the main slothlet module.
 * @internal
 * @private
 * @param {{named: string[], hasDefault: boolean, defaultName: string|null}} exports - Export information from parseExports
 * @returns {string} Generated .d.mts content
 */
function generateIndexDts(exports) {
	const namedExportDeclarations = exports.named
		.filter((name) => name !== "slothlet")
		.map((name) => `export const ${name}: any;`)
		.join("\n");

	return `/**
 * TypeScript declarations for @cldmv/slothlet index
 * 
 * This file is auto-generated by tools/build-exports.mjs
 * Run: npm run build:exports to regenerate
 */

// Re-export all types from the main slothlet module
export type * from "./dist/slothlet.d.mts";
// If you want runtime exports, use the implementation file instead:
export * from "./dist/slothlet.mts";

// Auto-generated named export declarations (these override the re-export above)
${namedExportDeclarations}

// Main slothlet export
declare const slothlet: any;
export default slothlet;
export { slothlet };
`;
}

/**
 * Main build function that orchestrates the entire export generation process.
 * Parses exports from src/slothlet.mjs and generates both index.mjs and TypeScript declaration files.
 * @package
 * @async
 * @returns {Promise<void>}
 * @throws {Error} When source files are not found or file operations fail
 *
 * @example
 * // Run directly as a script
 * node tools/build-exports.mjs
 *
 * @example
 * // Use programmatically
 * import { buildExports } from "./tools/build-exports.mjs";
 * await buildExports();
 */
async function buildExports() {
	console.log("üîß Building export statements for index files...\n");

	try {
		// Parse exports from src/slothlet.mjs
		const slothletPath = path.join(projectRoot, "src", "slothlet.mjs");
		console.log("üìñ Parsing exports from:", slothletPath);

		if (!fs.existsSync(slothletPath)) {
			throw new Error(`Source file not found: ${slothletPath}`);
		}

		const exports = parseExports(slothletPath);
		console.log("Found exports:");
		console.log("  Named exports:", exports.named);
		console.log("  Has default:", exports.hasDefault);
		console.log("  Default name:", exports.defaultName || "anonymous");

		// Generate index.d.mts in the types folder
		const indexDtsPath = path.join(projectRoot, "types", "index.d.mts");
		const indexDtsContent = generateIndexDts(exports);

		// Ensure types directory exists
		const typesDir = path.dirname(indexDtsPath);
		if (!fs.existsSync(typesDir)) {
			fs.mkdirSync(typesDir, { recursive: true });
		}

		fs.writeFileSync(indexDtsPath, indexDtsContent, "utf8");
		console.log("‚úÖ Generated:", indexDtsPath);

		console.log("\nüéâ Export build completed successfully!");
		console.log("üí° Remember to test the generated exports with: node test-exports.mjs");
	} catch (error) {
		console.error("‚ùå Export build failed:", error.message);
		process.exit(1);
	}
}

// Run if called directly
if (import.meta.url === `file://${process.argv[1]}` || process.argv[1].endsWith("build-exports.mjs")) {
	buildExports();
}

export { buildExports, parseExports, generateIndexDts };
