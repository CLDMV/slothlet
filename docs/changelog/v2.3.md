# Slothlet v2.3.0 Changelog

**Release Date**: October 16, 2025

## Overview

Version 2.3.0 introduces automatic context propagation for EventEmitters and class instances - ensuring AsyncLocalStorage context is preserved across all asynchronous boundaries without any code changes required from developers.

## ðŸ”„ New Features

### EventEmitter Context Propagation

Automatically preserves AsyncLocalStorage context across all EventEmitter callbacks using Node.js AsyncResource patterns.

**Key Benefits:**

- âœ… Automatic - No configuration needed
- âœ… Complete Context - Full `context` and `self` API access in all event handlers
- âœ… Nested Events - Works with any depth of EventEmitter nesting
- âœ… Universal Support - All EventEmitter methods automatically context-aware
- âœ… Production Ready - Uses Node.js AsyncResource for reliable propagation
- âœ… Clean Shutdown - Automatic AsyncResource cleanup
- âœ… Zero Overhead - Only wraps listeners when context is active

**Usage Example:**

```javascript
// api/tcp-server.mjs
import { self, context } from "@cldmv/slothlet/runtime";
import net from "node:net";

export function createTcpServer() {
	const server = net.createServer();

	// Connection handler maintains context automatically
	server.on("connection", (socket) => {
		console.log(`User: ${context.user}`); // âœ… Context preserved
		console.log(`API keys: ${Object.keys(self).length}`); // âœ… Full API access

		// Socket data handler also maintains context
		socket.on("data", (data) => {
			console.log(`Session: ${context.session}`); // âœ… Context preserved
			const processed = self.dataProcessor.handle(data.toString());
			socket.write(processed);
		});

		socket.on("error", (err) => {
			self.logger.error(`Error for user ${context.user}: ${err.message}`);
		});
	});

	return server;
}
```

**How It Works:**

1. EventEmitter instances are automatically wrapped with AsyncResource
2. All event listeners execute within proper async context
3. Context flows through: `on()`, `once()`, `addListener()`, `emit()`
4. Works with built-in Node.js modules (net, http, fs) and custom EventEmitters

### Class Instance Context Preservation

Automatic context wrapping for class methods using intelligent proxy detection:

**Before v2.3.0:**

```javascript
// Class methods lost context
class DatabaseService {
	query(sql) {
		console.log(context.user); // âŒ undefined
	}
}
```

**After v2.3.0:**

```javascript
// Class methods preserve context automatically
class DatabaseService {
	query(sql) {
		console.log(context.user); // âœ… Works!
		return self.validator.check(sql);
	}
}

export default new DatabaseService();
```

**How It Works:**

1. Class instances detected during module loading
2. Methods automatically wrapped with `runWithCtx()`
3. Context preserved through method calls
4. Works with complex object hierarchies

### Promise Proxy Fixes

Resolved critical "TypeError: Method Promise.prototype.then called on incompatible receiver":

**The Problem:**

```javascript
// v2.2.x and earlier
const result = await api.fetchData(); // âŒ TypeError
```

**The Solution:**

- Complete Promise method support (`.then()`, `.catch()`, `.finally()`)
- Cross-realm Promise compatibility using `util.types.isPromise()`
- Promise/A+ specification compliance
- Proper context preservation through Promise chains

**Implementation:**

```javascript
// Per-target Promise method wrapper memoization
const promiseMethodCache = new WeakMap();

// Cache invalidation on mutations
set(target, prop, value) {
	promiseMethodCache.delete(target);
	return Reflect.set(target, prop, value);
}
```

## ðŸ“Š Technical Improvements

### AsyncResource Integration

EventEmitter wrapping using Node.js AsyncResource patterns:

```javascript
import { AsyncResource } from "node:async_hooks";

class EventEmitterWrapper extends EventEmitter {
	constructor(emitter, ctx) {
		super();
		this._emitter = emitter;
		this._ctx = ctx;
		this._resources = new Map();
	}

	on(event, listener) {
		const resource = new AsyncResource(`EventEmitter:${event}`);
		const wrapped = (...args) => {
			return resource.runInAsyncScope(() => {
				return runWithCtx(this._ctx, listener, this, args);
			});
		};
		this._resources.set(listener, { wrapped, resource });
		return this._emitter.on(event, wrapped);
	}
}
```

### Promise Method Handling

Intelligent Promise detection and wrapping:

```javascript
const PROMISE_METHODS = ["then", "catch", "finally"];

function isPromise(value) {
	return util.types.isPromise(value) || (value && typeof value.then === "function");
}

// Wrap Promise methods with context preservation
if (isPromise(target) && PROMISE_METHODS.includes(prop)) {
	const method = target[prop];
	return (...args) => {
		const wrappedArgs = args.map((arg) => (typeof arg === "function" ? (...callArgs) => runWithCtx(ctx, arg, undefined, callArgs) : arg));
		return Reflect.apply(method, target, wrappedArgs);
	};
}
```

## ðŸ§¹ Code Quality Improvements

### Quote Standardization

Complete codebase standardization to double quotes:

```javascript
// Before: Inconsistent
import { self } from "@cldmv/slothlet/runtime";
const path = "api/module.mjs";

// After: Consistent
import { self } from "@cldmv/slothlet/runtime";
const path = "api/module.mjs";
```

### Node.js Import Modernization

Updated to use `node:` prefix throughout:

```javascript
// Before
import { AsyncResource } from "async_hooks";
import fs from "fs";

// After
import { AsyncResource } from "node:async_hooks";
import fs from "node:fs";
```

### TypeScript Definitions

Enhanced type generation and validation:

- Proper module resolution
- Cross-module type consistency
- Improved JSDoc typedef placement
- Build order enforcement (dist â†’ types â†’ validation)

## ðŸ§ª Testing

Comprehensive test coverage added:

**EventEmitter Tests:**

- TCP server/client context validation
- Nested event handler testing
- Multiple event types
- Async context verification

**Class Instance Tests:**

- Method wrapping validation
- Context preservation through calls
- Complex hierarchies
- Property access patterns

**Promise Tests:**

- `.then()`, `.catch()`, `.finally()` support
- Cross-realm compatibility
- Context preservation through chains
- Custom thenable objects

## Breaking Changes

None - all enhancements are backward compatible and automatic.

## Performance Impact

- EventEmitter wrapping: Minimal overhead with intelligent detection
- Promise proxy: Optimized with WeakMap-based caching
- Class wrapping: One-time cost during module loading

## Migration Guide

### Upgrading from v2.2.x

No code changes required! EventEmitter and class context preservation works automatically:

```javascript
// Your existing code just works:
import { self, context } from "@cldmv/slothlet/runtime";
import net from "node:net";

export function createServer() {
	const server = net.createServer();
	server.on("connection", (socket) => {
		// Context now available automatically!
		console.log(context.user);
	});
	return server;
}
```

## Use Cases

### TCP Server Context Isolation

```javascript
// api/server.mjs
import { self, context } from "@cldmv/slothlet/runtime";
import net from "node:net";

export function createServer(port) {
	const server = net.createServer();

	server.on("connection", (socket) => {
		console.log(`New connection for user: ${context.user}`);

		socket.on("data", (data) => {
			const processed = self.processor.handle(data, context.session);
			socket.write(processed);
		});

		socket.on("end", () => {
			self.logger.info(`Connection closed: ${context.user}`);
		});
	});

	server.listen(port);
	return server;
}
```

### HTTP Server with Context

```javascript
// api/http-server.mjs
import { self, context } from "@cldmv/slothlet/runtime";
import http from "node:http";

export function createHttpServer() {
	const server = http.createServer((req, res) => {
		console.log(`Request from: ${context.user}`);

		req.on("data", (chunk) => {
			// Context preserved in request events
			self.validator.check(chunk, context.permissions);
		});

		req.on("end", () => {
			const result = self.handler.process(req);
			res.end(result);
		});
	});

	return server;
}
```

## Related Documentation

- [Context Propagation Guide](../CONTEXT-PROPAGATION.md) - Complete guide
- [v2.2 Changelog](v2.2.md) - Case preservation features
- [v2.0 Changelog](v2.0.md) - Runtime system introduction

## Patch Releases

### v2.3.1

- Promise proxy fixes for `.then()` method compatibility
- Enhanced thenable support for custom Promise-like objects
- WeakMap-based caching for Promise method wrappers

### v2.3.2

- EventEmitter wrapping enhancements
- Class instance context preservation improvements
- TypeScript definition updates

---

**Full Changelog**: https://github.com/CLDMV/slothlet/compare/v2.2.0...v2.3.0
