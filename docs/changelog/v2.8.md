# Slothlet v2.8.0 Changelog

**Release Date**: December 26, 2025

## Overview

Version 2.8.0 introduces dynamic API extension with the `addApi()` method, comprehensive management method TypeScript support, and enhanced safety controls. This release enables runtime API modification while maintaining type safety and preventing accidental overwrites.

## ðŸŽ¯ Major Features

### Dynamic API Extension

New `addApi(apiPath, folderPath)` method for runtime API extension:

**Basic Usage:**

```javascript
const api = await slothlet({ dir: "./api" });

// Dynamically add plugins at runtime
await api.addApi("plugins", "./plugins-folder");

// Now use the extended API
api.plugins.myPlugin();
api.plugins.anotherPlugin.method();
```

**Deeply Nested Paths:**

```javascript
// Create nested API structures
await api.addApi("runtime.plugins", "./plugins");
await api.addApi("services.external", "./external-services");

// Access nested APIs
api.runtime.plugins.loader();
api.services.external.oauth.authenticate();
```

**Key Capabilities:**

- âœ… Load and merge modules at runtime without restart
- âœ… Support for deeply nested paths (automatic intermediate objects)
- âœ… Compatible with both lazy and eager loading modes
- âœ… Automatic live binding updates for multi-instance isolation
- âœ… Function.property pattern support (extend functions with properties)

**How It Works:**

```javascript
// 1. Parse dotted path
"runtime.plugins" â†’ ["runtime", "plugins"]

// 2. Navigate/create path
api â†’ api.runtime â†’ api.runtime.plugins

// 3. Load modules from folder
loadModulesFromFolder("./plugins-folder")

// 4. Merge into target location
Object.assign(api.runtime.plugins, newModules)

// 5. Update live bindings
mutateLiveBindingFunction(api, updatedApi)
```

### Management Methods TypeScript Support

Comprehensive TypeScript definitions for all management methods:

```typescript
interface SlothletAPI {
	// Dynamic API extension
	addApi(apiPath: string, folderPath: string): Promise<void>;

	// Cleanup and resource disposal
	shutdown(): Promise<void>;

	// API metadata inspection
	describe(showAll?: boolean): (string | symbol)[] | object | Promise<object>;

	// Your API methods...
	[key: string]: any;
}
```

**Entry Point Updates:**

```typescript
// index.mjs
export default function slothlet(options: SlothletOptions): Promise<SlothletAPI>;

// index.cjs
module.exports = function slothlet(options: SlothletOptions): Promise<SlothletAPI>;
```

## ðŸ›¡ï¸ Configuration & Safety

### New `allowApiOverwrite` Option

Control whether `addApi()` can overwrite existing endpoints:

**Default Behavior (v2.8.0+):**

```javascript
const api = await slothlet({
	dir: "./api",
	allowApiOverwrite: true // Default: allows overwrites
});

await api.addApi("plugins", "./plugins"); // âœ… Creates
await api.addApi("plugins", "./more-plugins"); // âš ï¸ Overwrites with warning
```

**Protected Mode:**

```javascript
const api = await slothlet({
	dir: "./api",
	allowApiOverwrite: false // Prevent accidental overwrites
});

await api.addApi("plugins", "./plugins"); // âœ… Creates
await api.addApi("plugins", "./more-plugins"); // âš ï¸ Logs warning, skips
// Warning: Refusing to overwrite existing API path "plugins" (allowApiOverwrite: false)
```

**Behavior:**

- `allowApiOverwrite: true` - Logs warning but proceeds with overwrite
- `allowApiOverwrite: false` - Logs warning and skips overwrite operation
- Warnings include data loss information

### Input Validation

Comprehensive validation prevents common errors:

**Path Validation:**

```javascript
// âœ… Valid paths
await api.addApi("plugins", "./plugins");
await api.addApi("runtime.plugins", "./plugins");
await api.addApi("  plugins  ", "./plugins"); // Trimmed automatically

// âŒ Invalid paths
await api.addApi("", "./plugins"); // Error: non-empty string required
await api.addApi("   ", "./plugins"); // Error: non-whitespace required
await api.addApi("plugins..nested", "./p"); // Error: consecutive dots
await api.addApi(".plugins", "./p"); // Error: leading dot
await api.addApi("plugins.", "./p"); // Error: trailing dot
```

**Folder Path Validation:**

```javascript
// âŒ Invalid folder paths
await api.addApi("plugins", null); // Error: folderPath must be string
await api.addApi("plugins", undefined); // Error: folderPath must be string
await api.addApi("plugins", 123); // Error: folderPath must be string
```

## ðŸ”§ Critical Fixes

### Non-Enumerable Management Methods

Fixed `mutateLiveBindingFunction` to properly copy management methods:

**The Problem:**

```javascript
// v2.7.x and earlier
const api = await slothlet({ dir: "./api" });

api.shutdown();  // âŒ TypeError: api.shutdown is not a function
api.addApi(...); // âŒ TypeError: api.addApi is not a function
```

**Root Cause:**

- `Object.entries()` only copies enumerable properties
- Management methods were non-enumerable
- Live binding mutation lost these methods

**The Solution:**

```javascript
// Explicitly copy non-enumerable management methods
function mutateLiveBindingFunction(oldTarget, newTarget) {
	// Copy enumerable properties
	for (const [key, value] of Object.entries(newTarget)) {
		oldTarget[key] = value;
	}

	// Explicitly copy management methods with descriptors
	const managementMethods = ["shutdown", "addApi", "describe"];
	for (const method of managementMethods) {
		if (method in newTarget) {
			const descriptor = Object.getOwnPropertyDescriptor(newTarget, method);
			if (descriptor) {
				Object.defineProperty(oldTarget, method, descriptor);
			}
		}
	}
}
```

### Conditional Enumerable Properties

Smart enumerable control based on context:

```javascript
// shutdown: enumerable when user-defined, hidden when management-only
Object.defineProperty(api, "shutdown", {
	value: shutdownFn,
	enumerable: hasUserShutdown, // true if user provided, false if default
	configurable: true,
	writable: false
});

// addApi: always hidden from iteration
Object.defineProperty(api, "addApi", {
	value: addApiFn,
	enumerable: false, // Always hidden
	configurable: true,
	writable: false
});

// describe: hidden by default
Object.defineProperty(api, "describe", {
	value: describeFn,
	enumerable: false,
	configurable: true,
	writable: false
});
```

**Benefits:**

- `Object.keys(api)` shows only API methods
- Management methods accessible but hidden from iteration
- User-defined shutdown visible when provided
- Clean API surface for documentation

## ðŸ“š Use Cases

### Plugin System

```javascript
// Core API
const api = await slothlet({ dir: "./core-api" });

// Dynamically load plugins at startup
const pluginDirs = await fs.readdir("./plugins");
for (const dir of pluginDirs) {
	await api.addApi(`plugins.${dir}`, `./plugins/${dir}`);
}

// Use plugins
api.plugins.authentication.login(credentials);
api.plugins.cache.get(key);
api.plugins.logging.info(message);
```

### Multi-Tenant Extensions

```javascript
// Base API
const api = await slothlet({ dir: "./api" });

// Load tenant-specific extensions
async function loadTenantExtensions(tenantId) {
	const tenantPath = `./tenants/${tenantId}/extensions`;
	if (fs.existsSync(tenantPath)) {
		await api.addApi(`tenants.${tenantId}`, tenantPath);
	}
}

await loadTenantExtensions("acme-corp");
await loadTenantExtensions("widgets-inc");

// Tenant-specific APIs
api.tenants.acmeCorp.customReport();
api.tenants.widgetsInc.specialFeature();
```

### Feature Flags

```javascript
const api = await slothlet({
	dir: "./api",
	allowApiOverwrite: false // Prevent accidental overwrites
});

// Enable experimental features conditionally
if (config.enableBetaFeatures) {
	await api.addApi("beta", "./features/beta");
}

if (config.enableExperimental) {
	await api.addApi("experimental", "./features/experimental");
}

// Use when available
if (api.beta) {
	api.beta.newFeature();
}
```

### Hot Module Reload

```javascript
const api = await slothlet({
	dir: "./api",
	allowApiOverwrite: true // Allow reloading
});

// Watch for changes and reload
fs.watch("./plugins", async (eventType, filename) => {
	if (eventType === "change") {
		console.log(`Reloading plugin: ${filename}`);
		await api.addApi("plugins", "./plugins");
		console.log("Plugin reloaded successfully");
	}
});
```

## âš ï¸ Important Considerations

### Race Conditions

**Warning**: Concurrent `addApi()` calls may cause race conditions:

```javascript
// âŒ Potential race condition
await Promise.all([api.addApi("plugins.auth", "./auth"), api.addApi("plugins.cache", "./cache")]);

// âœ… Sequential execution recommended
await api.addApi("plugins.auth", "./auth");
await api.addApi("plugins.cache", "./cache");
```

### Shallow Merge Behavior

`addApi()` uses `Object.assign()` for shallow merging:

```javascript
// Existing API
api.plugins = {
	auth: { login() {}, logout() {} },
	cache: { get() {}, set() {} }
};

// Adding new plugins
await api.addApi("plugins", "./new-plugins");
// Result: Shallow merge replaces top-level keys
// If new-plugins has "auth", entire api.plugins.auth is replaced
```

### Function.Property Pattern

Supports extending functions with properties:

```javascript
// plugins/processor.mjs
export default function process(data) {
	return data.toUpperCase();
}
process.advanced = (data, opts) => { ... };
process.config = { timeout: 5000 };

// After addApi:
api.plugins.processor("test")              // Calls function
api.plugins.processor.advanced("test", {}) // Accesses property
api.plugins.processor.config.timeout       // Accesses nested property
```

## Breaking Changes

None - `addApi()` is a new additive feature with sensible defaults maintaining backward compatibility.

## Performance Impact

Minimal - `addApi()` is typically called during initialization or infrequently at runtime:

- Module loading: Same cost as initial load
- Path navigation: O(depth) where depth is dotted path segments
- Live binding update: O(1) property assignment
- No overhead when not used

## Migration Guide

### Upgrading from v2.7.x

No code changes required. To use dynamic extension:

```javascript
const api = await slothlet({ dir: "./api" });

// Add new APIs at runtime
await api.addApi("plugins", "./plugins");
await api.addApi("extensions.custom", "./custom-extensions");
```

### TypeScript Users

Update type imports to benefit from management method types:

```typescript
import slothlet, { SlothletAPI, SlothletOptions } from "@cldmv/slothlet";

const api: SlothletAPI = await slothlet({
	dir: "./api"
});

// Now fully typed:
await api.addApi("plugins", "./plugins");
await api.shutdown();
const metadata = api.describe();
```

## Related Documentation

- [API Documentation](../generated/API.md) - Complete API reference with `addApi()`
- [v2.7 Changelog](v2.7.md) - Hook system introduction
- [Module Structure](../MODULE-STRUCTURE.md) - Module organization

## Patch Releases

None yet for v2.8.x series.

---

**Full Changelog**: https://github.com/CLDMV/slothlet/compare/v2.7.0...v2.8.0
