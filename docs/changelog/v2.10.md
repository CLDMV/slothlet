# Slothlet v2.10.0 Changelog

**Release Date**: December 31, 2025

## Overview

Version 2.10.0 introduces function metadata tagging and introspection capabilities, enabling runtime identification and authorization of dynamically loaded modules. This release also fixes a critical bug in lazy mode where `addApi()` would lose existing folder contents when merging into pre-existing namespaces.

## ğŸ†• New Features

### Function Metadata System

Tag loaded functions with immutable metadata for security, auditing, and runtime introspection:

**Basic Metadata Tagging:**

```javascript
const api = await slothlet({ dir: "./api" });

// Tag functions with custom metadata
await api.addApi("plugins.trusted", "./trusted-plugins", {
	trusted: true,
	version: "1.0.0",
	author: "Alice"
});

await api.addApi("plugins.untrusted", "./third-party", {
	trusted: false,
	source: "external"
});

// Access metadata
const meta = api.plugins.trusted.someFunc.__metadata;
console.log(meta.trusted); // true
console.log(meta.version); // "1.0.0"
```

**Metadata Immutability:**

```javascript
// Metadata is deeply immutable
const meta = api.plugins.someFunc.__metadata;
meta.trusted = false; // âŒ Error in strict mode, silently fails otherwise
delete meta.version; // âŒ Silently ignored
meta.newProp = "ok"; // âœ… Can add new properties
meta.newProp = "no"; // âŒ But they become immutable immediately

// Nested objects are also frozen
meta.config.setting = false; // âŒ Cannot modify nested properties
meta.permissions.push("admin"); // âŒ Cannot modify arrays
```

**Auto-Added Metadata:**

```javascript
// sourceFolder is automatically added
await api.addApi("plugins", "./plugins", { trusted: true });

const meta = api.plugins.someFunc.__metadata;
console.log(meta.sourceFolder);
// "P:\\path\\to\\plugins" (absolute path)
```

### metadataAPI - Runtime Introspection

New `metadataAPI` export for introspecting function metadata from within slothlet context:

```javascript
import { metadataAPI } from "@cldmv/slothlet/runtime";

// Get metadata by dot-notation path
const meta = await metadataAPI.get("plugins.trusted.someFunc");
console.log(meta.trusted); // true

// Get caller's metadata (from stack trace)
async function myFunction() {
	const callerMeta = await metadataAPI.caller();
	if (!callerMeta?.trusted) {
		throw new Error("Untrusted caller");
	}
	// ... proceed with trusted operation
}

// Get current function's metadata
export async function checkSelf() {
	const selfMeta = await metadataAPI.self();
	console.log("I am trusted:", selfMeta.trusted);
}
```

**Authorization Example:**

```javascript
// api_tests/api_test/security/authorize.mjs
import { metadataAPI } from "@cldmv/slothlet/runtime";

export async function sensitiveOperation() {
	// Check caller's metadata
	const caller = await metadataAPI.caller();

	if (!caller?.trusted) {
		throw new Error("Unauthorized: Caller is not trusted");
	}

	// Proceed with sensitive operation
	return "Success";
}
```

### Empty Metadata Handling

```javascript
// Passing empty metadata object doesn't create metadata
await api.addApi("plugins", "./plugins", {});
console.log(api.plugins.someFunc.__metadata); // undefined

// Also cleans stale metadata from cached CJS modules
await api.addApi("plugins", "./plugins"); // No metadata param
// Previous metadata from cached modules is removed
```

## ğŸ› Bug Fixes

### Critical: Lazy Mode addApi Merge Issue

**Fixed**: In lazy mode, calling `addApi()` to merge into an existing namespace would lose the original folder contents.

**Problem:**

```javascript
const api = await slothlet({ dir: "./api", mode: "lazy" });
// api.nested exists from initial load (contains 'date' subfolder)

await api.addApi("nested", "./more-modules");
// âŒ BUG: api.nested.date was lost, only new modules present
```

**Root Cause:**

- Lazy mode loads folders as proxy functions that materialize on-demand
- `addApi()` detected the proxy but didn't materialize it before merging
- `Object.assign()` added properties to the unmaterialized proxy function object
- This lost the original folder structure from the initial load

**Solution:**

```javascript
// In add_api.mjs - detect and materialize lazy proxies before merge
const targetValue = currentTarget[finalKey];
if (typeof targetValue === "function" && targetValue.__slothletPath) {
	// Access property to trigger materialization
	const _ = targetValue.__trigger;
	// Await proxy to wait for materialization completion
	await targetValue();
	// Now currentTarget[finalKey] is the materialized object
}
```

**After Fix:**

```javascript
const api = await slothlet({ dir: "./api", mode: "lazy" });
await api.addApi("nested", "./more-modules");
// âœ… FIXED: Both original and new modules accessible
console.log(typeof api.nested.date); // "object" - original preserved
console.log(typeof api.nested.newModule); // "object" - new added
```

This fix ensures that lazy mode merging works identically to eager mode, preserving all existing content when adding new modules to pre-existing namespaces.

## ğŸ“ Refactoring

### Metadata Module Extraction

Metadata utilities extracted to dedicated module for better organization:

**New File: `src/lib/helpers/api_builder/metadata.mjs`**

- `createImmutableMetadata()` - Deep-freezing with Proxy enforcement
- `cleanMetadata()` - Remove stale metadata from cached modules
- `tagLoadedFunctions()` - Recursive metadata tagging

**Updated: `src/lib/helpers/api_builder/add_api.mjs`**

- Imports metadata functions instead of defining them
- ~270 lines shorter, focused on core addApi logic

## ğŸ”„ Updated APIs

### addApi() Method

Now accepts optional third parameter for metadata:

```javascript
/**
 * @param {string} apiPath - Dot-notation path (e.g., "plugins.security")
 * @param {string} folderPath - Path to folder with modules
 * @param {object} [metadata={}] - Metadata to attach to all loaded functions
 * @returns {Promise<void>}
 */
await api.addApi(apiPath, folderPath, metadata);
```

### Runtime Exports

New `metadataAPI` export added to runtime module:

```javascript
// Previously: self, context, reference
export { self, context, reference, metadataAPI };
```

## ğŸ“Š Test Coverage

### New Test Suite

**`tests/test-metadata-api.mjs`** - Comprehensive metadata testing:

- 96 tests across 8 mode combinations (eager/lazy Ã— async/live Ã— hooks true/false)
- 100% pass rate
- Tests cover:
  - Basic metadata tagging and immutability
  - Nested object and array deep-freezing
  - metadataAPI introspection methods
  - Authorization patterns
  - Multiple addApi calls
  - Edge cases (empty metadata, missing functions)

**Test Matrix:**

```text
Mode   Runtime  Hooks   Tests
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
EAGER  ASYNC    false   12/12 âœ…
EAGER  ASYNC    true    12/12 âœ…
EAGER  LIVE     false   12/12 âœ…
EAGER  LIVE     true    12/12 âœ…
LAZY   ASYNC    false   12/12 âœ…
LAZY   ASYNC    true    12/12 âœ…
LAZY   LIVE     false   12/12 âœ…
LAZY   LIVE     true    12/12 âœ…
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Total                   96/96 âœ…
```

## ğŸ”§ Technical Details

### Metadata Implementation

**Deep Freezing:**

- Recursively freezes all nested objects and arrays
- Prevents modification of security-critical properties
- Uses `Object.freeze()` on all nested structures

**Proxy-Based Immutability:**

- Proxy `set` trap returns `false` to reject modifications
- Throws `TypeError` in strict mode
- Allows adding new properties (which then become immutable)
- Proxy `deleteProperty` trap silently ignores deletions

**CommonJS Cache Handling:**

- CJS modules cache function object references
- Query parameters don't create separate CJS module instances
- `cleanMetadata()` removes stale metadata from cached functions
- Called automatically when `addApi()` invoked without metadata

### Lazy Proxy Materialization

**How Lazy Proxies Work:**

1. Folders load as proxy functions with `__slothletPath` property
2. Accessing any property triggers `get` trap
3. Get trap calls `_materialize()` which starts async loading
4. When complete, `replacePlaceholder()` replaces proxy with materialized object

**Materialization Trigger:**

```javascript
// Access any property to trigger get trap
const _ = lazyProxy.__trigger;
// Await proxy to wait for materialization
await lazyProxy();
// Now parent[key] contains materialized object
```

## ğŸ“š Documentation

### New Documentation

- **`docs/METADATA.md`** - Complete metadata system guide
- **`docs/changelog/v2.10.md`** - This changelog

### Updated Documentation

- **README.md** - Updated addApi() signature and examples
- **API documentation** - Added metadata parameter documentation

## âš™ï¸ Configuration

No new configuration options. Metadata system works with existing slothlet configuration.

## ğŸ”„ Migration Guide

### From v2.9.x to v2.10.0

**No Breaking Changes** - Fully backward compatible.

**Optional Enhancements:**

```javascript
// v2.9.x - still works
await api.addApi("plugins", "./plugins");

// v2.10.0 - enhanced with metadata
await api.addApi("plugins", "./plugins", {
	trusted: true,
	version: "1.0.0"
});
```

**New Capabilities:**

```javascript
// Use metadataAPI for introspection
import { metadataAPI } from "@cldmv/slothlet/runtime";

export async function restrictedFunction() {
	const caller = await metadataAPI.caller();
	if (!caller?.trusted) {
		throw new Error("Unauthorized");
	}
	// ... secure operation
}
```

## ğŸ¯ Use Cases

### Plugin Security

```javascript
// Load trusted plugins
await api.addApi("plugins.core", "./core-plugins", {
	trusted: true,
	permissions: ["read", "write", "admin"]
});

// Load third-party plugins
await api.addApi("plugins.thirdParty", "./external", {
	trusted: false,
	permissions: ["read"]
});

// Enforce security in sensitive operations
export async function deleteData(id) {
	const caller = await metadataAPI.caller();
	if (!caller?.trusted || !caller.permissions.includes("admin")) {
		throw new Error("Insufficient permissions");
	}
	// ... delete operation
}
```

### Multi-Tenant SaaS

```javascript
// Load tenant-specific modules
await api.addApi("tenants.acme", "./tenants/acme", {
	tenantId: "acme",
	tier: "enterprise"
});

await api.addApi("tenants.startup", "./tenants/startup", {
	tenantId: "startup",
	tier: "basic"
});

// Enforce tier restrictions
export async function advancedFeature() {
	const caller = await metadataAPI.caller();
	if (caller?.tier !== "enterprise") {
		throw new Error("Feature requires enterprise tier");
	}
	// ... advanced feature
}
```

### Audit Logging

```javascript
// Tag modules with version info
await api.addApi("services", "./services", {
	version: "2.3.1",
	author: "TeamA",
	deployedAt: new Date().toISOString()
});

// Log all calls with version info
export async function criticalOperation() {
	const caller = await metadataAPI.caller();
	const self = await metadataAPI.self();

	console.log("AUDIT:", {
		operation: "criticalOperation",
		callerVersion: caller?.version,
		selfVersion: self?.version,
		timestamp: Date.now()
	});

	// ... operation
}
```

## ğŸ”® Future Enhancements

Potential additions for future versions:

- **Source map integration**: Automatic file/line tracking for better stack traces
- **Metadata schemas**: Validate metadata structure at load time
- **Metadata events**: Hooks for metadata access/modification attempts
- **Metadata inheritance**: Child modules inherit parent metadata
- **Query API**: Search functions by metadata properties

## ğŸ“¦ Package Info

- **Version**: 2.10.0
- **Node.js**: â‰¥18.0.0
- **License**: MIT
- **Repository**: https://github.com/catalyzedmotivation/slothlet

## ğŸ™ Credits

Thanks to all contributors who helped identify and fix the lazy mode merge issue, and provided feedback on the metadata system design.
